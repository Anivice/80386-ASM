# Chapter 3.4: Memory Addressing (And Some Other Notes)

## Addressing Modes

The 80386 supports the following **effective address calculations** in real mode:

### 1. Direct Addressing
The effective address is directly specified.

#### Example:
```nasm
    mov ax, [1234h]  ; Load AX with the word at physical address (DS × 16) + 0x1234
```

### 2. Register Indirect Addressing
The effective address is contained in a register.

#### Example:
```nasm
    mov ax, [bx]                ; Load AX with the word at the address pointed by BX (DS is implied)
```

### 3. Indexed Addressing
An index register (`SI` or `DI`) is used as the effective address.

#### Example:
```nasm
    mov ax, [si]                ; Load AX with the word at the address in SI
```

### 4. Base + Index Addressing
Combines a base register (`BX`, `BP`) and an index register (`SI`, `DI`).
The 8086 allows only specific combinations of base address and index registers
for memory addressing:

```nasm
    [bx + si]
    [bx + di]
    [bp + si]
    [bp + di]
```

This limitation means we can manipulate the index register indirectly, such as using
`inc bx` or similar instructions, without modifying the original index register itself.

#### Example:
```nasm
    mov ax, [bx + si]           ; Load AX with the word at the address BX + SI
```

### 5. Base + Index + Displacement Addressing
Combines a base register, an index register, and a displacement (constant offset).

#### Example:
```nasm
    mov ax, [bp + di + 0x1234]  ; Load AX with the word at BP + DI + 0x1234 (SS is implied)
```

### 6. Displacement Only
The effective address is determined entirely by a displacement value.

#### Example:
```nasm
    mov ax, [0x1234]            ; Load AX with the word at offset 0x1234 in the segment DS
```

## Real Mode Memory Map
1 MB address space is divided into:

| Address Range         | Description                                             |
|-----------------------|---------------------------------------------------------|
| 0x00000 – 0x003FF     | Interrupt Vector Table: Stores pointers for interrupts. |
| 0x00400 – 0x004FF     | BIOS Data Area: Holds BIOS variables.                   |
| 0x00500 – 0x9FFFF     | Conventional Memory: General-purpose memory.            |
| 0xA0000 – 0xBFFFF     | Video Memory: For text and graphics.                    |
| 0xF0000 – 0xFFFFF     | BIOS ROM: Contains the system BIOS.                     |

---

[Chapter 4]()

[Back To Main Page](../README.md)

